## 참조
단일페이지로 코틀린 기본문법에대해 다룬 사이트, 본글에 참고하여 작성하였다.  
[1️⃣](https://junghun0.github.io/2019/07/20/kotlin-android/) [2️⃣](https://duooo-story.tistory.com/42)  

본 글에 작성하지는 않았지만, 쳬계적으로 잘 설명한 사이트, 해당 사이트에서 글목록 확인할 것 
[1️⃣](https://leveloper.tistory.com/138) [2️⃣](https://dev-kimji1.medium.com/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EC%B4%88-814c9b2bc82a) [3️⃣](https://velog.io/@hhi-5258/kotlin-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EC%B4%881) [4️⃣](https://velog.io/@gosgjung/%EC%BD%94%ED%8B%80%EB%A6%B0%EC%96%B8%EC%96%B4-%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90-%EC%B4%9D%EC%A0%95%EB%A6%AC-%EC%8A%A4%EC%95%95%EC%A3%BC%EC%9D%98)

## 주요 특징 
+ 문장끝에 세미콜론(;) 를 쓰지 않아도됨
+ new 키워드르 쓰지않고 객체 생성
+ 타입 추론을 지원하므로 일반적인 경우 타입을 적지 않아도 됨
+ Null값에대해 명확히 함

### 가변 / 불변 구분짓는 변수할당
+ var : var 로 선언한 변수는 값을 변경할 수 있다.
+ val : val 로 선언한 상수는 값을 변경할 수 없다.(Java에서의 final)
  ```KOTLIN
//자바의 final String name = "Hokuen"; 과 동일
val name: String = "Hokeun"
//컴파일 에러: 값이 한번 할당되면 다른 값을 할당할 수 없다.
name = "keunHo"

//자바의 String name = "Hokeun"; 과 동일
var name: String = "Hokeun"
//성공: var 로 선언되었기 때문에 다른 값을 할당할 수 있다.
name = "keunHo"
  ```
변수의 가변/불변과 유사하게 컬렉션 자료형에 대해서도 가변/불변 여부를 구분한다. 객체에 할당된 값이 아닌 컬렉션 내 포함된 자료들을 추가하거나 삭제할 수 있는지 여부를 구분한다. 자료의 가변/불변 여부는 인터페이스로 구분하며, 불변 인터페이스의 경우 삽입/삭제/수정을 위한 함수가 없다.
```KOTLIN
//자료를 변경할 수 없는 리스트 생성
val immutable: List<String> = listOf("foo","test","sample")
//컴파일 에러 : add() 함수가 정의되어 있지 않다.
immutable.add("fail")

//자료를 변경할 수 있는 리스트 생성
val mutable: MutableList<String> = mutableListOf("foo","test","sample")
//성공 : MutableList에는 자료를 수정할 수 있는 함수가 정의되어 있다.
mutable.add("success")
```
### 값 및 변수 선언
타입을 먼저 적고 그 다음 이름을 적는 자바와 달리, 코틀린에서는 이름을 먼저 적고 타입을 적는다.
```KOTLIN
val a: String = "foo"
val b = "bar"

//선언 시 자료를 할당하지 않으면 타입을 꼭 붙여야한다.
val c: String
//자료 할당
c = "abc"

var d: Int = 0
d += 1
```
### 함수(메서드) 선언
패키지 수준이나 클래스, 객체 내부에 정의할 수 있으며, fun이라는 명령어 사용.  
fun 함수명 (인자1: 자료형1, 인자2: 자료형2, ...): 반환 자료형{}
```KOTLIN
fun greet(name: String) : Unit {
    println("Hello, $name!")
}

fun sum(a: Int, b: Int) : Int {
    return a + b
}

/////////////////////////////
fun greet(name: String) {
    println("Hello, $name!")
}
```
함수의 반환값에 사용하는 Unit은 자바의 void 와 유사하게 사용하며 Unit을 반환하는 함수는 위와 같이 반환형을 생략할 수 있다.

### 클래스 및 인터페이스 선언
```KOTLIN
class Foo {
    val foo: String = "foo"

    fun foo() {
        ...
    }
}

interface Bar{
    fun bar()
}
```

### 조건문
```KOTLIN
val s = if ( a > b){
  val tmp = a/b;
  tmp+100
  }
  else{
  0
  }
```
if문의 경우 변수에 직접 if/else를 사용하여 대입이 가능하다.
```KOTLIN
fun max(a: Int, b: Int) : Int {
    if (a > b){
        return a
    }else{
        return b
    }
}
```

```KOTLIN
fun countItems(count: Int){
    when(count){
        1 -> println("There is $count item.")
        else -> println("There are $count item.")
    }
}
```
when문은 자바의 switch와 동일한 역할
### 반복문
range를 이용한 for
```KOTLIN
for (x in 1..5) {
  	println(x)
}
```
in을 통한 숫자범위
```KOTLIN
val items = listOf("foo", "bar", "baz")
for (item in items){
    println("item: $item")
}
```
코틀린은 for-each문만 지원, while문은 자바와 동일
```KOTLIN
for(i in 0 until 10 step 2){
    println(i)
}
 
for(i in 0.until(10).step(2)) println(i)

//// 0 2 4 6 8
```
for문 내부적으로 labels를 통해 간단하게 처리

```KOTLIN
loop@for ( i in 1..10) {
	for( j in 1..10) {
    	if ( i == 1 && j == 2) break@loop
        println("i : $i, j : $j")
        }
    }
}
```
loop문 사용(@)과 변수값출력($)

### 동등성, 동일성
자바에서 == 의 경우 객체는 동일성, 원시타입은 동등성을 계산하게 된다.
코틀린에서는 === 는 동일성, == (equals 호출)는 동등성을 검사한다.

### 스마트 캐스트
바에서 instanceof 연산자를 사용하여 객체의 자료형을 하고, 다시 변환하는 과정을 거치는 두번의 작업이 진행된다. 코틀린은 이 과정이 좀 더 단순화 되었다. 동일하게 when 구조에서도 is를 통하여 스마트 캐스트가 가능하다.
```KOTLIN
val tt : Any = "String"
 
val len : Int = if(tt is String){
    tt.length
}else{
    0
}
```
### 생성자
코틀린에서는 init 블록을 사용하여 기본 생성자를 대체한다. 생성자에 인자가 필요한 경우는 다음과 같이 인자를 받을 수 있다. 코틀린에서는 이를 주 생성자(primary constructor)라 부르며, 여기에서 받은 인자는 init 블록에서도 사용할 수 있다.
```KOTLIN
class Foo {
    init {
        //생성자에서 수행할 작업들
        ...
    }
}
```
코틀린에서 생성자의 인자를 통해 바로 클래스 내부의 프로퍼티에 값을 할당할 수 있다. 이 경우 생성자의 인자를 통해 프로퍼티 선언을 대신하므로 추가로 프로퍼티를 선언하지 않아도 된다. 다음은 인자로 받은 값을 사용하여 내부의 필드 및 프로퍼티에 값을 할당하는 생성자의 예이다. 생성자의 인자에서 프로퍼티 선언이 함께 이루어지고, 값 할당 또한 생성자 호출과 동시에 수행되므로 자바에 비해 비약적으로 코드가 짧다
```KOTLIN
class Foo(val a: Int, var b: Char)
```
주 생성자 외에 다른 형태의 생성자가 필요한 경우 constructor 키워드를 사용하여 추가 생성자를 선언할 수 있다.
```KOTLIN
class Foo(val a: Int, var b: Char){
    //a의 값만 인자로 받는 추가 생성자
    //기본 생성자를 반드시 호출해야 한다.
    constructor(a: Int) : this(a, 0)
    //두 인자의 값을 모두 0으로 지정하는 생성자
    constructor(): this(0, 0)
}
```



### 기본자료형
+ 숫자형(Double / Float / Long / Int / Short / Byte)
  기본적으로 자료형을 알아서 맞춰주며, 10.0 을 입력하면 Double로 받아들임 굳이 10.0을 float형으로 받기위해선 10.0f 처럼 해줘야함
  ```KOTLIN
  var a:Int       = 10
  var b:Long      = 10L
  var c:Double    = 10.0
  var d:Float     = 10.0f

  var aa = 10         // Int
  var bb = 10L        // Long
  var cc = 10.0       // Double
  var dd = 10.0f      // Float
  ```
  
+ 문자형(


### 문(statement)과 식(expression)
+ 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있음
+ 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않음
+ kotlin 에서 if문은 식
+ ‘블록의 마지막 식이 블록의 결과'라는 규칙은 블록이 값을 만들어내야 하는 경우 항상 성립  // 함수에 대해서는 성립하지 않음, 식이 본문인 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return문이 반드시 있어야 함

#### 코틀린 NULL 처리 - 물음표(?) / 느낌표(!!) / let / lateinit / 제네릭, 플렛폼 타입 [👉](https://tourspace.tistory.com/114)

코틀린에서는 자바보다 null처리를 더욱 명확하게 한다. 이 떄문에 NullPointerException 오류를 현저히 낮출 수 있다.

1. null이 될수있는 type
```KOTLIN
var abc:String? =null
```
abc라는 변수의 타입에 ?를 붙임으로서 null이 가능한 변수임을 명시적으로 표현. 때문에 null을 집어넣어도 에러가 나지 않는다.  

2. null safe operator  
코틀린에서 null을 안전하게 처리하기위해 ?. 연산자를 지원한다.
```KOTLIN
fun println(s: String?) { 
  val print: String? = s?.toUpperCase() 
   println(print) 
} 

fun main(args: Array) { 
  println("abc") 
  println(null) 
}
```
?. 연산자를 사용하면 앞의 변수가 null이 아닐때만 오른쪽 함수가 수행되고 null이면 null을 반환한다. if (s != null) s.toUpperCase() else null 와 같은뜻!, 연속적 사용이 가능함

3. Elvis operator
?. 연산자는 좌항이 null이면 null을 반환한다. 비슷하게 좌항이 null일 때 null반환이 아닌 default 값을 주고 싶다면?? 이때 ?: 를 사용한다.
```KOTLIN
fun getName(str: String?) { 
  val name = str ?: "Unknown" 
}
```
if (str != null) str else "Unknown" 와 같은 뜻! 우항으로 return이나 throw도 넣을 수 있다.

```KOTLIN
value!!.value
```
!!는 null이 아니다 라고 선언해주는 역할




아직 작성중..
