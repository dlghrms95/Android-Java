## int 와 Integer의 차이점
+ int는 원시타입이고 Integer는 참조타입(객체)이다. 잘 구분해서 사용하자    
자바에서는 자동으로 박싱, 언박싱이 잘 되어서 원시타입과 참조타입을 코드 구현상에서 같이 사용해도  
크게 불편함이 없다. 예를들어 Integer 5와 int 5 를 비교한다면 같다고 리턴이 된다.  
하지만, 그 크기가 커져서 Integer 2222222220과  int 2222222220을 비교하면 같다고 리턴되지 않는다.  
객체와 객체를 비교할 때도 마찬가지이다. 값이 같더라도 가리키는 주소가 달라서 다음과 같은 결과를 가진다.
```JAva
public class Main
{
    public static void main(String[] args)
    {
        Integer a = 1000, b = 1000;
        System.out.println(a == b);

        Integer c = 100, d = 100;
        System.out.println(c == d);
    }
}
//false와 true반환
```
+ 원시타입(첫글자 소문자)은 쉽게말해 정수, 실수 , 문자 논리 리터럴 등의 실제 데이터 값을 저장하는 타입이고,  
  참조타입(첫글자 대문자)은 객체의 번지를 참조(주소를 저장)하는 타입으로 메모리 번지값을 통해 객체를 참조한다. 

### valueOf() vs parseInt() 
Integer.valueOf(String) 는 Integer클래스를 리턴하기 때문에 산술 연산이 불가능하며,  
Integer.parseInt(String) 는 int형을 리턴하기 때문에 산술 연산이 가능하다.

 ### 원시타입과 참조타입의 기능적 차이
+ 원시타입은 Null을 담을수 없고, 참조타입은 Null을 입력값으로 받을 수 있다.
```JAVA
int i = null; // 불가능
Integer integer = null; // 가능
```
+ 원시타입은 제네릭 타입에서 사용이 불가하고, 참조타입은 제네릭 타입에서 사용이 가능하다.
```JAVA
List<int> i; // 불가능
List<Integer> integer; // 가능
```
### 그럼에도 불구하고 원시타입을 쓰는 이유
+ 원시 타입은 스택 메모리에 값이 존재한다. 반면에 참조 타입은 하나의 인스턴스이기 때문에  
스택 메모리에는 참조값만 있고, 실제 값은 힙 메모리에 존재하게 된다. 그리고 값을 필요로 할 때마다  
언박싱 과정을 거쳐야 하니 원시 타입과 비교해서 접근 속도가 느려지게 된다.
+ 참조타입의 경우 차지하는 메모리양이 원시타입보다 훨씬 많다.

결과적으로 성능과 메모리에 장접이 있는 원시 타입을 먼저 고려해보고,  
Null값을 다루거나(sql 연동) 제네릭 타입에서 사용해야 한다면 참조타입을 사용하는 것이 옳겠다. 

### 번외
+ 원시타입 int배열을 선언하면
```JAVA
int[] array = new int[8]; // 배열 생성후 초기화 하면 배열의 주소가 할당(배열 변수는 참조변수에 속함) 초기값 0
// new를 해주지 않으면 해당 배열은 null값을 가져서 이를 활용하면 NullpointerException 발생
```
+ 객체배열 사용 - Array(배열)도 초기화하고 Object(객체)도 초기화 시켜주어야한다.
```JAVA
Car[] car = new Car[8]; // 각 배열엔 아직 null값만 존재

for(int i=0;i<car.length;i++) { // 배열안의 자동차 클래스를 초기화 시켜주어야
	car[i] = new Car();           // 배열에 주소값이 제대로 설정된다.
}
```
